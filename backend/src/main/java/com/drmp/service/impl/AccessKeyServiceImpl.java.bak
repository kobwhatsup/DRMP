package com.drmp.service.impl;

import com.drmp.dto.AccessKeyCreateDTO;
import com.drmp.dto.AccessKeyResponseDTO;
import com.drmp.dto.AccessKeyUpdateDTO;
import com.drmp.dto.KeyUsageStatsDTO;
import com.drmp.entity.AccessKey;
import com.drmp.entity.KeyType;
import com.drmp.entity.KeyUsageLog;
import com.drmp.entity.KeySecurityEvent;
import com.drmp.exception.BusinessException;
import com.drmp.repository.AccessKeyRepository;
import com.drmp.repository.KeyTypeRepository;
import com.drmp.repository.KeyUsageLogRepository;
import com.drmp.repository.KeySecurityEventRepository;
import com.drmp.service.AccessKeyService;
import com.drmp.utils.KeyGenerator;
import com.drmp.utils.SecurityUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * 访问密钥服务实现
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AccessKeyServiceImpl implements AccessKeyService {

    private final AccessKeyRepository accessKeyRepository;
    private final KeyTypeRepository keyTypeRepository;
    private final KeyUsageLogRepository keyUsageLogRepository;
    private final KeySecurityEventRepository keySecurityEventRepository;
    private final RedisTemplate<String, Object> redisTemplate;

    @Override
    @Transactional
    public AccessKeyResponseDTO createAccessKey(AccessKeyCreateDTO createDTO) {
        // 验证密钥类型
        KeyType keyType = keyTypeRepository.findByCode(createDTO.getKeyTypeCode())
                .orElseThrow(() -> new BusinessException("密钥类型不存在"));

        // 生成密钥ID和秘钥
        String keyId = KeyGenerator.generateKeyId();
        String keySecret = KeyGenerator.generateKeySecret();
        String encryptedSecret = SecurityUtils.encryptSecret(keySecret);

        // 创建访问密钥
        AccessKey accessKey = new AccessKey();
        accessKey.setKeyId(keyId);
        accessKey.setKeySecret(encryptedSecret);
        accessKey.setKeyType(keyType);
        accessKey.setName(createDTO.getName());
        accessKey.setDescription(createDTO.getDescription());
        accessKey.setOwnerType(AccessKey.OwnerType.valueOf(createDTO.getOwnerType()));
        accessKey.setOwnerId(createDTO.getOwnerId());
        accessKey.setPermissions(createDTO.getPermissions());
        accessKey.setIpWhitelist(createDTO.getIpWhitelist());
        accessKey.setRateLimitPerMinute(createDTO.getRateLimitPerMinute());
        accessKey.setExpiresAt(createDTO.getExpiresAt());
        accessKey.setCreatedBy(SecurityUtils.getCurrentUserId());

        accessKey = accessKeyRepository.save(accessKey);

        // 缓存密钥信息
        cacheAccessKey(accessKey);

        AccessKeyResponseDTO responseDTO = convertToResponseDTO(accessKey);
        responseDTO.setKeySecret(keySecret); // 只在创建时返回明文秘钥

        log.info("创建访问密钥成功: keyId={}, name={}, owner={}:{}", 
                keyId, createDTO.getName(), createDTO.getOwnerType(), createDTO.getOwnerId());

        return responseDTO;
    }

    @Override
    @Transactional
    public AccessKeyResponseDTO updateAccessKey(Long id, AccessKeyUpdateDTO updateDTO) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));

        // 更新基本信息
        if (updateDTO.getName() != null) {
            accessKey.setName(updateDTO.getName());
        }
        if (updateDTO.getDescription() != null) {
            accessKey.setDescription(updateDTO.getDescription());
        }
        if (updateDTO.getPermissions() != null) {
            accessKey.setPermissions(updateDTO.getPermissions());
        }
        if (updateDTO.getIpWhitelist() != null) {
            accessKey.setIpWhitelist(updateDTO.getIpWhitelist());
        }
        if (updateDTO.getRateLimitPerMinute() != null) {
            accessKey.setRateLimitPerMinute(updateDTO.getRateLimitPerMinute());
        }
        if (updateDTO.getExpiresAt() != null) {
            accessKey.setExpiresAt(updateDTO.getExpiresAt());
        }

        accessKey = accessKeyRepository.save(accessKey);

        // 更新缓存
        cacheAccessKey(accessKey);

        log.info("更新访问密钥成功: keyId={}", accessKey.getKeyId());

        return convertToResponseDTO(accessKey);
    }

    @Override
    public AccessKeyResponseDTO getAccessKeyById(Long id) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));
        return convertToResponseDTO(accessKey);
    }

    @Override
    public AccessKey getAccessKeyByKeyId(String keyId) {
        // 先从缓存获取
        String cacheKey = "access_key:" + keyId;
        AccessKey cachedKey = (AccessKey) redisTemplate.opsForValue().get(cacheKey);
        if (cachedKey != null) {
            return cachedKey;
        }

        // 从数据库获取
        AccessKey accessKey = accessKeyRepository.findByKeyId(keyId)
                .orElse(null);

        if (accessKey != null) {
            cacheAccessKey(accessKey);
        }

        return accessKey;
    }

    @Override
    public Page<AccessKeyResponseDTO> getAccessKeys(String ownerType, Long ownerId, String status, 
                                                   String keyTypeCode, Pageable pageable) {
        Page<AccessKey> accessKeys = accessKeyRepository.findByConditions(
                ownerType, ownerId, status, keyTypeCode, pageable);
        return accessKeys.map(this::convertToResponseDTO);
    }

    @Override
    @Transactional
    public void revokeAccessKey(Long id, String reason) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));

        accessKey.setStatus(AccessKey.KeyStatus.REVOKED);
        accessKeyRepository.save(accessKey);

        // 从缓存中移除
        removeCachedAccessKey(accessKey.getKeyId());

        // 记录安全事件
        recordSecurityEvent(accessKey.getKeyId(), KeySecurityEvent.EventType.KEY_COMPROMISED, 
                          KeySecurityEvent.Severity.HIGH, reason);

        log.info("吊销访问密钥: keyId={}, reason={}", accessKey.getKeyId(), reason);
    }

    @Override
    @Transactional
    public void suspendAccessKey(Long id, String reason) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));

        accessKey.setStatus(AccessKey.KeyStatus.SUSPENDED);
        accessKeyRepository.save(accessKey);

        // 从缓存中移除
        removeCachedAccessKey(accessKey.getKeyId());

        log.info("暂停访问密钥: keyId={}, reason={}", accessKey.getKeyId(), reason);
    }

    @Override
    @Transactional
    public void activateAccessKey(Long id) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));

        accessKey.setStatus(AccessKey.KeyStatus.ACTIVE);
        accessKeyRepository.save(accessKey);

        // 更新缓存
        cacheAccessKey(accessKey);

        log.info("激活访问密钥: keyId={}", accessKey.getKeyId());
    }

    @Override
    @Transactional
    public String regenerateKeySecret(Long id, String reason) {
        AccessKey accessKey = accessKeyRepository.findById(id)
                .orElseThrow(() -> new BusinessException("访问密钥不存在"));

        String newKeySecret = KeyGenerator.generateKeySecret();
        String encryptedSecret = SecurityUtils.encryptSecret(newKeySecret);

        accessKey.setKeySecret(encryptedSecret);
        accessKeyRepository.save(accessKey);

        // 更新缓存
        cacheAccessKey(accessKey);

        log.info("重新生成密钥秘钥: keyId={}, reason={}", accessKey.getKeyId(), reason);

        return newKeySecret;
    }

    @Override
    public boolean validateAccessKey(String keyId, String keySecret, String clientIp, String endpoint) {
        AccessKey accessKey = getAccessKeyByKeyId(keyId);
        if (accessKey == null) {
            recordSecurityEvent(keyId, KeySecurityEvent.EventType.UNAUTHORIZED_ACCESS, 
                              KeySecurityEvent.Severity.MEDIUM, "密钥不存在");
            return false;
        }

        // 验证密钥状态
        if (!accessKey.isValid()) {
            recordSecurityEvent(keyId, KeySecurityEvent.EventType.UNAUTHORIZED_ACCESS, 
                              KeySecurityEvent.Severity.MEDIUM, "密钥已失效");
            return false;
        }

        // 验证秘钥
        if (!SecurityUtils.verifySecret(keySecret, accessKey.getKeySecret())) {
            recordSecurityEvent(keyId, KeySecurityEvent.EventType.UNAUTHORIZED_ACCESS, 
                              KeySecurityEvent.Severity.HIGH, "密钥秘钥错误");
            return false;
        }

        // 验证IP白名单
        if (!accessKey.isIpAllowed(clientIp)) {
            recordSecurityEvent(keyId, KeySecurityEvent.EventType.IP_BLOCKED, 
                              KeySecurityEvent.Severity.MEDIUM, "IP不在白名单中");
            return false;
        }

        // 验证访问频率限制
        if (!checkRateLimit(keyId, clientIp)) {
            recordSecurityEvent(keyId, KeySecurityEvent.EventType.RATE_LIMIT_EXCEEDED, 
                              KeySecurityEvent.Severity.LOW, "超过访问频率限制");
            return false;
        }

        // 更新最后使用时间
        accessKey.setLastUsedAt(LocalDateTime.now());
        accessKeyRepository.save(accessKey);

        return true;
    }

    @Override
    public void logKeyUsage(String keyId, String requestId, String endpoint, String method, 
                           String ipAddress, String userAgent, Integer responseStatus, 
                           Integer responseTime, Long requestSize, Long responseSize, String errorMessage) {
        KeyUsageLog usageLog = new KeyUsageLog();
        usageLog.setKeyId(keyId);
        usageLog.setRequestId(requestId);
        usageLog.setEndpoint(endpoint);
        usageLog.setMethod(method);
        usageLog.setIpAddress(ipAddress);
        usageLog.setUserAgent(userAgent);
        usageLog.setResponseStatus(responseStatus);
        usageLog.setResponseTimeMs(responseTime);
        usageLog.setRequestSize(requestSize);
        usageLog.setResponseSize(responseSize);
        usageLog.setErrorMessage(errorMessage);

        keyUsageLogRepository.save(usageLog);
    }

    @Override
    public boolean checkRateLimit(String keyId, String clientIp) {
        String rateLimitKey = "rate_limit:" + keyId + ":" + getCurrentMinute();
        String count = (String) redisTemplate.opsForValue().get(rateLimitKey);
        
        int currentCount = count != null ? Integer.parseInt(count) : 0;
        
        AccessKey accessKey = getAccessKeyByKeyId(keyId);
        if (accessKey != null && accessKey.isRateLimitExceeded(currentCount)) {
            return false;
        }

        // 增加计数
        redisTemplate.opsForValue().increment(rateLimitKey);
        redisTemplate.expire(rateLimitKey, 1, TimeUnit.MINUTES);

        return true;
    }

    @Override
    public KeyUsageStatsDTO getKeyUsageStats(String keyId, String startDate, String endDate) {
        // TODO: 实现密钥使用统计查询
        return new KeyUsageStatsDTO();
    }

    @Override
    public List<AccessKeyResponseDTO> getExpiringKeys(int days) {
        LocalDateTime expiryDate = LocalDateTime.now().plusDays(days);
        List<AccessKey> expiringKeys = accessKeyRepository.findExpiringKeys(expiryDate);
        return expiringKeys.stream()
                .map(this::convertToResponseDTO)
                .toList();
    }

    @Override
    @Transactional
    public void cleanupExpiredKeys() {
        List<AccessKey> expiredKeys = accessKeyRepository.findExpiredKeys(LocalDateTime.now());
        for (AccessKey key : expiredKeys) {
            key.setStatus(AccessKey.KeyStatus.EXPIRED);
            removeCachedAccessKey(key.getKeyId());
        }
        accessKeyRepository.saveAll(expiredKeys);
        
        log.info("清理过期密钥: count={}", expiredKeys.size());
    }

    @Override
    public byte[] exportAccessKeys(String ownerType, Long ownerId, String format) {
        // TODO: 实现密钥列表导出
        return new byte[0];
    }

    /**
     * 缓存访问密钥
     */
    private void cacheAccessKey(AccessKey accessKey) {
        String cacheKey = "access_key:" + accessKey.getKeyId();
        redisTemplate.opsForValue().set(cacheKey, accessKey, 1, TimeUnit.HOURS);
    }

    /**
     * 移除缓存的访问密钥
     */
    private void removeCachedAccessKey(String keyId) {
        String cacheKey = "access_key:" + keyId;
        redisTemplate.delete(cacheKey);
    }

    /**
     * 记录安全事件
     */
    private void recordSecurityEvent(String keyId, KeySecurityEvent.EventType eventType, 
                                   KeySecurityEvent.Severity severity, String details) {
        KeySecurityEvent event = new KeySecurityEvent();
        event.setKeyId(keyId);
        event.setEventType(eventType);
        event.setSeverity(severity);
        event.setDetails(details);
        event.setIsResolved(false);

        keySecurityEventRepository.save(event);
    }

    /**
     * 获取当前分钟数（用于访问频率限制）
     */
    private String getCurrentMinute() {
        return String.valueOf(System.currentTimeMillis() / 60000);
    }

    /**
     * 转换为响应DTO
     */
    private AccessKeyResponseDTO convertToResponseDTO(AccessKey accessKey) {
        AccessKeyResponseDTO dto = new AccessKeyResponseDTO();
        dto.setId(accessKey.getId());
        dto.setKeyId(accessKey.getKeyId());
        dto.setName(accessKey.getName());
        dto.setDescription(accessKey.getDescription());
        dto.setKeyTypeCode(accessKey.getKeyType().getCode());
        dto.setKeyTypeName(accessKey.getKeyType().getName());
        dto.setOwnerType(accessKey.getOwnerType().name());
        dto.setOwnerId(accessKey.getOwnerId());
        dto.setStatus(accessKey.getStatus().name());
        dto.setPermissions(accessKey.getPermissions());
        dto.setIpWhitelist(accessKey.getIpWhitelist());
        dto.setRateLimitPerMinute(accessKey.getRateLimitPerMinute());
        dto.setExpiresAt(accessKey.getExpiresAt());
        dto.setLastUsedAt(accessKey.getLastUsedAt());
        dto.setCreatedAt(accessKey.getCreatedAt());
        dto.setUpdatedAt(accessKey.getUpdatedAt());
        return dto;
    }
}