import React, { useState, useEffect } from 'react';
import {
  Badge,
  Button,
  Drawer,
  List,
  Avatar,
  Typography,
  Space,
  Tag,
  Empty,
  Spin,
  Divider,
  Tooltip,
  notification as antNotification
} from 'antd';
import {
  BellOutlined,
  CheckOutlined,
  DeleteOutlined,
  SettingOutlined,
  ReloadOutlined
} from '@ant-design/icons';
import dayjs from 'dayjs';
import relativeTime from 'dayjs/plugin/relativeTime';
import { useAuth } from '../../hooks/useAuth';
import { notificationAPI } from '../../services/api';
import type { NotificationMessage, NotificationStats } from '../../services/notificationAPI';

dayjs.extend(relativeTime);

const { Text } = Typography;


const NotificationCenter: React.FC = () => {
  const { user } = useAuth();
  const [visible, setVisible] = useState(false);
  const [loading, setLoading] = useState(false);
  const [messages, setMessages] = useState<NotificationMessage[]>([]);
  const [stats, setStats] = useState<NotificationStats>({ total: 0, unread: 0, read: 0 });
  const [webSocket, setWebSocket] = useState<WebSocket | null>(null);

  // åˆå§‹åŒ–WebSocketè¿žæŽ¥
  useEffect(() => {
    if (user?.id) {
      initWebSocket();
      loadNotifications();
      loadStatistics();
    }

    return () => {
      if (webSocket) {
        webSocket.close();
      }
    };
  }, [user?.id]);

  const initWebSocket = () => {
    try {
      const wsUrl = `ws://localhost:8080/ws/notifications?userId=${user?.id}`;
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        console.log('WebSocketè¿žæŽ¥å·²å»ºç«‹');
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleWebSocketMessage(data);
        } catch (error) {
          console.error('è§£æžWebSocketæ¶ˆæ¯å¤±è´¥:', error);
        }
      };

      ws.onclose = (event) => {
        console.log('WebSocketè¿žæŽ¥å·²å…³é—­:', event.reason);
        // å°è¯•é‡è¿ž
        setTimeout(() => {
          if (user?.id) {
            initWebSocket();
          }
        }, 5000);
      };

      ws.onerror = (error) => {
        console.error('WebSocketè¿žæŽ¥é”™è¯¯:', error);
      };

      setWebSocket(ws);
    } catch (error) {
      console.error('åˆå§‹åŒ–WebSocketå¤±è´¥:', error);
    }
  };

  const handleWebSocketMessage = (data: any) => {
    if (data.type === 'notification') {
      const newMessage = data.data;
      
      // æ›´æ–°æ¶ˆæ¯åˆ—è¡¨
      setMessages(prev => [newMessage, ...prev]);
      
      // æ›´æ–°ç»Ÿè®¡
      setStats((prev: NotificationStats) => ({
        ...prev,
        total: prev.total + 1,
        unread: prev.unread + 1
      }));
      
      // æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥
      showDesktopNotification(newMessage);
    }
  };

  const showDesktopNotification = (message: NotificationMessage) => {
    // æµè§ˆå™¨é€šçŸ¥
    if (Notification.permission === 'granted') {
      new Notification(message.title, {
        body: message.content,
        icon: '/favicon.ico'
      });
    }
    
    // Antdé€šçŸ¥
    const priorityConfig = {
      URGENT: { type: 'error' as const, duration: 0 },
      HIGH: { type: 'warning' as const, duration: 6 },
      NORMAL: { type: 'info' as const, duration: 4 },
      LOW: { type: 'success' as const, duration: 3 }
    };
    
    const config = priorityConfig[message.priority as keyof typeof priorityConfig] || priorityConfig.NORMAL;
    
    antNotification[config.type]({
      message: message.title,
      description: message.content,
      duration: config.duration,
      placement: 'topRight'
    });
  };

  const loadNotifications = async () => {
    if (!user?.id) return;
    
    setLoading(true);
    try {
      const messages = await notificationAPI.getUnreadMessages(String(user.id));
      setMessages(messages);
    } catch (error) {
      console.error('åŠ è½½é€šçŸ¥å¤±è´¥:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadStatistics = async () => {
    if (!user?.id) return;
    
    try {
      const stats = await notificationAPI.getMessageStatistics(String(user.id));
      setStats(stats);
    } catch (error) {
      console.error('åŠ è½½ç»Ÿè®¡å¤±è´¥:', error);
    }
  };

  const markAsRead = async (messageId: number) => {
    if (!user?.id) return;
    
    try {
      await notificationAPI.markAsRead(messageId, String(user.id));
      if (true) {
        setMessages(prev => 
          prev.map(msg => 
            msg.id === messageId 
              ? { ...msg, status: 'read', readAt: new Date().toISOString() }
              : msg
          )
        );
        setStats((prev: NotificationStats) => ({
          ...prev,
          unread: Math.max(0, prev.unread - 1),
          read: prev.read + 1
        }));
      }
    } catch (error) {
      console.error('æ ‡è®°å·²è¯»å¤±è´¥:', error);
    }
  };

  const markAllAsRead = async () => {
    const unreadMessages = messages.filter(msg => msg.status !== 'read');
    
    for (const message of unreadMessages) {
      await markAsRead(message.id);
    }
  };

  const getPriorityColor = (priority: string) => {
    const colors = {
      URGENT: 'red',
      HIGH: 'orange',
      NORMAL: 'blue',
      LOW: 'green'
    };
    return colors[priority as keyof typeof colors] || 'blue';
  };

  const getTypeIcon = (type: string) => {
    const icons = {
      CASE_ASSIGNMENT: 'ðŸ“‹',
      CONTRACT_SIGNED: 'ðŸ“„',
      PAYMENT_RECEIVED: 'ðŸ’°',
      SYSTEM_ALERT: 'âš ï¸'
    };
    return icons[type as keyof typeof icons] || 'ðŸ“¢';
  };

  const requestNotificationPermission = () => {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
  };

  // è¯·æ±‚é€šçŸ¥æƒé™
  useEffect(() => {
    requestNotificationPermission();
  }, []);

  return (
    <>
      <Badge count={stats.unread} size="small" offset={[-2, 2]}>
        <Button
          type="text"
          icon={<BellOutlined />}
          onClick={() => setVisible(true)}
          style={{ fontSize: '16px' }}
        />
      </Badge>

      <Drawer
        title={
          <Space>
            <BellOutlined />
            é€šçŸ¥ä¸­å¿ƒ
            <Tag color="blue">{stats.unread} æœªè¯»</Tag>
          </Space>
        }
        placement="right"
        onClose={() => setVisible(false)}
        open={visible}
        width={400}
        extra={
          <Space>
            <Tooltip title="æ ‡è®°å…¨éƒ¨å·²è¯»">
              <Button
                type="text"
                icon={<CheckOutlined />}
                onClick={markAllAsRead}
                disabled={stats.unread === 0}
              />
            </Tooltip>
            <Tooltip title="åˆ·æ–°">
              <Button
                type="text"
                icon={<ReloadOutlined />}
                onClick={() => {
                  loadNotifications();
                  loadStatistics();
                }}
              />
            </Tooltip>
            <Tooltip title="è®¾ç½®">
              <Button
                type="text"
                icon={<SettingOutlined />}
              />
            </Tooltip>
          </Space>
        }
      >
        <Spin spinning={loading}>
          {messages.length === 0 ? (
            <Empty
              description="æš‚æ— é€šçŸ¥æ¶ˆæ¯"
              image={Empty.PRESENTED_IMAGE_SIMPLE}
            />
          ) : (
            <List
              dataSource={messages}
              renderItem={(message) => (
                <List.Item
                  style={{
                    backgroundColor: message.status === 'read' ? '#f9f9f9' : '#fff',
                    opacity: message.status === 'read' ? 0.8 : 1,
                    marginBottom: '8px',
                    borderRadius: '6px',
                    border: '1px solid #f0f0f0',
                    padding: '12px'
                  }}
                  actions={[
                    message.status !== 'read' && (
                      <Button
                        type="text"
                        size="small"
                        icon={<CheckOutlined />}
                        onClick={() => markAsRead(message.id)}
                      />
                    )
                  ].filter(Boolean)}
                >
                  <List.Item.Meta
                    avatar={
                      <Avatar size="small">
                        {getTypeIcon(message.type)}
                      </Avatar>
                    }
                    title={
                      <Space>
                        <Text strong={message.status !== 'read'}>
                          {message.title}
                        </Text>
                        <Tag 
                          color={getPriorityColor(message.priority)}
                        >
                          {message.priority}
                        </Tag>
                      </Space>
                    }
                    description={
                      <div>
                        <Text type="secondary" style={{ fontSize: '12px' }}>
                          {message.content}
                        </Text>
                        <br />
                        <Text type="secondary" style={{ fontSize: '11px' }}>
                          {dayjs(message.createdAt).fromNow()}
                        </Text>
                      </div>
                    }
                  />
                </List.Item>
              )}
            />
          )}
        </Spin>

        <Divider />
        
        <div style={{ textAlign: 'center', color: '#999', fontSize: '12px' }}>
          <Space split={<Divider type="vertical" />}>
            <span>æ€»è®¡: {stats.total}</span>
            <span>æœªè¯»: {stats.unread}</span>
            <span>å·²è¯»: {stats.read}</span>
          </Space>
        </div>
      </Drawer>
    </>
  );
};

export default NotificationCenter;